<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Multiplayer Shape Shooter Arena</title>
    <!-- Load Tailwind CSS for utility classes on UI elements -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load Three.js for 3D rendering -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        /* Apply Inter font and set up full screen canvas */
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            overflow: hidden; /* Hide scrollbars */
            background-color: #1a1a1a;
            user-select: none;
        }

        canvas {
            display: block;
        }

        /* --- Crosshair Styling --- */
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 8px;
            height: 8px;
            margin: -4px 0 0 -4px;
            border-radius: 50%;
            border: 2px solid white;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
            pointer-events: none; /* Allows clicks to pass through */
            z-index: 1000;
        }
    </style>
</head>
<body>

    <!-- UI Overlay for Instructions and Crosshair -->
    <div id="game-ui" class="absolute inset-0 pointer-events-none z-50 flex flex-col items-center justify-center">
        
        <!-- Score Display (TOP LEFT) -->
        <div id="score-display" class="absolute top-4 left-4 text-white text-3xl font-extrabold p-3 bg-gray-800 bg-opacity-50 rounded-lg pointer-events-none shadow-xl">
            Score: 0
        </div>

        <!-- User ID Display (Bottom Left - MANDATORY for multiplayer coordination) -->
        <div id="user-id-display" class="absolute bottom-4 left-4 text-xs text-white p-2 bg-gray-800 bg-opacity-70 rounded-md pointer-events-none shadow-lg">
            Connecting...
        </div>

        <!-- Health Display (TOP RIGHT) -->
        <div id="health-container" class="absolute top-4 right-4 p-3 bg-gray-800 bg-opacity-50 rounded-lg pointer-events-none shadow-xl w-64 md:w-80">
            <div class="text-white text-lg font-bold mb-1">Health</div>
            <div class="h-4 bg-red-900 rounded-full overflow-hidden">
                <div id="health-bar" class="h-full bg-red-500 transition-all duration-300 rounded-full" style="width: 100%;"></div>
            </div>
        </div>

        <!-- Crosshair -->
        <div id="crosshair"></div>

        <!-- Lock Message / Game Over Screen -->
        <div id="lock-message" class="bg-indigo-600 text-white p-6 rounded-xl shadow-2xl transition-opacity duration-300 opacity-100 mt-64 pointer-events-auto cursor-pointer flex flex-col items-center">
            <h2 class="text-3xl font-extrabold mb-3">Click to Enter the Game</h2>
            <p class="text-lg">WASD: Move | SPACE: Jump | Left Click: Shoot</p>
            <p class="mt-4 text-sm text-indigo-200" id="lock-hint">Press ESC to unlock the mouse.</p>
        </div>
    </div>

    <!-- The Three.js Renderer will draw into the body -->

    <script type="module">
        // --- FIREBASE IMPORTS ---
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, onSnapshot, collection, query, updateDoc, writeBatch, serverTimestamp, getDocs, limit, setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- CORE VARIABLES ---
        let scene, camera, renderer;
        let playerContainer; 
        let lastTime = performance.now();
        let isLocked = false;
        let score = 0; 

        // --- FIREBASE VARIABLES ---
        let app, db, auth;
        let userId; 
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const targetsCollectionRef = () => collection(db, 'artifacts', appId, 'public', 'data', 'targets');
        const playersCollectionRef = () => collection(db, 'artifacts', appId, 'public', 'data', 'players');
        const otherPlayers = new Map(); // Map for other players' meshes
        const targetMeshToId = new Map(); // Map: Firestore ID -> THREE.js Mesh

        // Player movement properties
        const player = {
            height: 1.8,
            radius: 0.5,
            velocity: new THREE.Vector3(),
            direction: new THREE.Vector3(),
            onGround: false,
            jumpForce: 35, 
            moveSpeed: 25, 
            gravity: 45,
            rotationX: 0,
            landingTimer: 0, 
            landingStunDuration: 0.1,
            health: 100, // Player Health
            isAlive: true  // Game state
        };

        // Arrays and constants
        const targets = [];
        const projectiles = [];
        const projectileSpeed = 300; 
        const TARGET_HALF_SIZE = 0.75; 
        const COLLISION_BUFFER = 0.05; 
        
        // --- FIXED WORLD CONSTANTS ---
        const WORLD_SIZE = 1000; 
        const MAX_CUBES = 500;   
        const WALL_HEIGHT = 50; 

        // ENEMY CONSTANTS
        const ENEMY_SPEED = 3.0; 
        const DAMAGE_RANGE = 2.0; 
        const DAMAGE_PER_SECOND = 20; 
        
        // --- TARGET SHAPES AND COLORS ---
        const TARGET_GEOMETRIES = [
            { name: 'Box', geometry: new THREE.BoxGeometry(1.5, 1.5, 1.5) },
            { name: 'Sphere', geometry: new THREE.SphereGeometry(0.85, 16, 16) }, 
            { name: 'Cone', geometry: new THREE.ConeGeometry(0.85, 1.7, 16) }, 
            { name: 'Dodecahedron', geometry: new THREE.DodecahedronGeometry(0.85) }, 
        ];

        const TARGET_COLORS = [
            0x4ade80, 0xfacc15, 0xef4444, 0x8b5cf6, 0xec4899, 0x06b6d4,
        ];

        // Materials
        const GROUND_MATERIAL = new THREE.MeshPhongMaterial({ color: 0x4caf50 }); 
        const WALL_MATERIAL = new THREE.MeshPhongMaterial({ color: 0x4a4e69 }); 

        // HTML UI Elements
        const lockMessage = document.getElementById('lock-message');
        const crosshair = document.getElementById('crosshair');
        const scoreDisplay = document.getElementById('score-display');
        const healthBar = document.getElementById('health-bar');
        const lockHint = document.getElementById('lock-hint');


        // --- UTILITY FUNCTIONS ---

        function updateUI() {
            scoreDisplay.innerText = `Score: ${score}`;
            const healthPercentage = Math.max(0, player.health);
            healthBar.style.width = `${healthPercentage}%`;
            
            if (healthPercentage > 60) {
                healthBar.style.backgroundColor = '#10b981'; 
            } else if (healthPercentage > 25) {
                healthBar.style.backgroundColor = '#f59e0b'; 
            } else {
                healthBar.style.backgroundColor = '#ef4444'; 
            }
        }

        // Resets player state and clears dynamic world objects (not environment)
        function resetGame() {
            player.health = 100;
            player.isAlive = true;
            player.velocity.set(0, 0, 0);
            player.direction.set(0, 0, 0);
            score = 0;

            // Clear projectiles
            projectiles.forEach(p => scene.remove(p));
            projectiles.length = 0;
            
            // Teleport player back to origin
            playerContainer.position.set(0, player.height, 0);

            // Re-render targets based on current (hit/unhit) database state
            targets.forEach(t => scene.remove(t));
            targets.length = 0;
            targetMeshToId.clear();
            
            // Re-fetch targets (The listener will do this automatically via snapshot)
            
            updateUI();
        }
        
        // --- INITIALIZATION ---
        function init() {
            // 1. Scene Setup
            scene = new THREE.Scene();
            const skyColor = 0x87ceeb;
            scene.background = new THREE.Color(skyColor); 
            scene.fog = new THREE.Fog(skyColor, 200, 400); 

            // 2. Camera and Player Container Setup 
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 0); 

            playerContainer = new THREE.Group();
            playerContainer.position.set(0, player.height, 0); 
            scene.add(playerContainer);
            playerContainer.add(camera); 

            // 3. Renderer Setup
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            // 4. Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
            directionalLight.position.set(20, 50, 20);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 100;
            directionalLight.shadow.camera.left = -100;
            directionalLight.shadow.camera.right = 100;
            directionalLight.shadow.camera.top = 100;
            directionalLight.shadow.camera.bottom = -100;
            scene.add(directionalLight);

            // 5. Environment generation (Static, runs only once)
            createEnvironment(); 

            // 6. Firebase Setup
            setupFirebase();

            // 7. Event Listeners
            setupPointerLock();
            window.addEventListener('resize', onWindowResize, false);
            document.addEventListener('keydown', onKeyDown, false);
            document.addEventListener('keyup', onKeyUp, false);
            document.addEventListener('click', onShoot, false);

            // Start the game loop
            animate();
        }
        
        function createEnvironment() {
            // 1. Create Ground
            const geometry = new THREE.PlaneGeometry(WORLD_SIZE, WORLD_SIZE);
            const ground = new THREE.Mesh(geometry, GROUND_MATERIAL);
            ground.position.set(0, 0, 0);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            ground.name = 'Ground';
            scene.add(ground);
            
            // 2. Create the physical walls and ceiling
            const halfWorld = WORLD_SIZE / 2;
            const wallCenterY = WALL_HEIGHT / 2;
            const wallGeometry = new THREE.PlaneGeometry(WORLD_SIZE, WALL_HEIGHT);
            
            const walls = [
                { x: halfWorld, y: wallCenterY, z: 0, rotationY: Math.PI / 2, name: 'WallX+' }, 
                { x: -halfWorld, y: wallCenterY, z: 0, rotationY: -Math.PI / 2, name: 'WallX-' },
                { x: 0, y: wallCenterY, z: halfWorld, rotationY: Math.PI, name: 'WallZ+' },
                { x: 0, y: wallCenterY, z: -halfWorld, rotationY: 0, name: 'WallZ-' }
            ];

            walls.forEach(wallData => {
                const wall = new THREE.Mesh(wallGeometry, WALL_MATERIAL);
                wall.position.set(wallData.x, wallData.y, wallData.z);
                wall.rotation.y = wallData.rotationY;
                wall.receiveShadow = true;
                wall.castShadow = true;
                wall.name = wallData.name;
                scene.add(wall);
            });
            
            // Ceiling
            const ceilingGeometry = new THREE.PlaneGeometry(WORLD_SIZE, WORLD_SIZE);
            const ceilingMaterial = new THREE.MeshPhongMaterial({ color: 0x333333, side: THREE.DoubleSide });
            const ceiling = new THREE.Mesh(ceilingGeometry, ceilingMaterial);
            ceiling.position.set(0, WALL_HEIGHT, 0);
            ceiling.rotation.x = Math.PI / 2; 
            ceiling.receiveShadow = true;
            ceiling.name = 'Ceiling';
            scene.add(ceiling);
        }

        // --- FIREBASE & MULTIPLAYER LOGIC ---

        function setupFirebase() {
            const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};

            try {
                app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);
                setLogLevel('Debug');

                onAuthStateChanged(auth, async (user) => {
                    if (user) {
                        userId = user.uid;
                        document.getElementById('user-id-display').innerText = `Your ID: ${userId}`;
                        // Game state initialization starts here once authenticated
                        await initializeGameData(); 
                        setupMultiplayerListeners();
                    } else {
                        if (typeof __initial_auth_token !== 'undefined') {
                            await signInWithCustomToken(auth, __initial_auth_token);
                        } else {
                            await signInAnonymously(auth);
                        }
                    }
                });

            } catch (e) {
                console.error("Firebase Initialization Error:", e);
                lockHint.innerText = "Error initializing multiplayer. Check console.";
            }
        }

        async function initializeGameData() {
            if (!db) return;

            const targetsRef = targetsCollectionRef();
            
            // Query only one document to check if targets exist (efficient check)
            const q = query(targetsRef, limit(1));
            const snapshot = await getDocs(q).catch(e => console.error("Error checking target existence:", e));
            
            if (snapshot && snapshot.size > 0) {
                console.log("Targets already exist. Waiting for real-time listener.");
                return; 
            }

            // --- Create Targets in Firestore (Only if they don't exist) ---
            const halfWorld = WORLD_SIZE / 2;
            const batch = writeBatch(db); 

            for (let i = 0; i < MAX_CUBES; i++) {
                const x = (Math.random() - 0.5) * WORLD_SIZE; 
                const z = (Math.random() - 0.5) * WORLD_SIZE; 
                let y = Math.random() * 3 + 1.5; 
                
                if (Math.abs(x) < 5 && Math.abs(z) < 5) continue;
                
                const shapeIndex = Math.floor(Math.random() * TARGET_GEOMETRIES.length);
                const colorIndex = Math.floor(Math.random() * TARGET_COLORS.length);
                
                const targetData = {
                    p: [x, y, z], // Position array [x, y, z]
                    sI: shapeIndex, // Shape Index
                    cI: colorIndex, // Color Index
                    isHit: false,
                    lastHitBy: null
                };
                
                const newDocRef = doc(targetsRef);
                batch.set(newDocRef, targetData);
            }
            
            batch.commit().then(() => {
                console.log(`Initial ${MAX_CUBES} targets created in Firestore.`);
            }).catch(e => {
                console.error("Error creating initial targets batch:", e);
            });
        }
        
        function getFirestoreIdFromMesh(targetMesh) {
            for (const [id, mesh] of targetMeshToId.entries()) {
                if (mesh === targetMesh) return id;
            }
            return null;
        }

        // Creates the THREE.js mesh based on data from Firestore
        function createLocalTargetMesh(position, shapeIndex, colorIndex) {
            const shapeData = TARGET_GEOMETRIES[shapeIndex];
            const color = TARGET_COLORS[colorIndex];
            
            const material = new THREE.MeshPhongMaterial({ color: color });
            const targetMesh = new THREE.Mesh(shapeData.geometry, material); 
            
            targetMesh.position.copy(position);
            targetMesh.castShadow = true;
            targetMesh.receiveShadow = true;
            targetMesh.name = 'TargetShape';
            
            targetMesh.userData.isHit = false; 
            targetMesh.userData.initialY = position.y; 
            targetMesh.userData.initialColor = color; 
            
            scene.add(targetMesh);
            return targetMesh;
        }

        function createOtherPlayerMesh(id) {
            // Visualize other players as orange cylinders
            const geometry = new THREE.CylinderGeometry(player.radius, player.radius, player.height, 16);
            const material = new THREE.MeshPhongMaterial({ color: 0xff8c00 }); // Deep Orange
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.y = player.height / 2; // Center the cylinder on the ground
            mesh.name = `PlayerBody_${id}`;
            
            const container = new THREE.Group();
            container.add(mesh);
            container.position.y = 0;
            
            scene.add(container);
            return container;
        }

        function updateMultiplayer(delta) {
            if (!db || !userId || !player.isAlive || !isLocked) return;

            // Throttle Firestore writes to ~10 times per second
            const now = performance.now();
            if (now - updateMultiplayer.lastWrite < 100) return;
            updateMultiplayer.lastWrite = now;

            // Send local player position, rotation, score, and health
            const playerRef = doc(playersCollectionRef(), userId);
            
            const playerData = {
                p: [playerContainer.position.x, playerContainer.position.y, playerContainer.position.z],
                rY: playerContainer.rotation.y, 
                score: score,
                health: player.health,
                timestamp: serverTimestamp() // Used for cleanup/presence check
            };

            setDoc(playerRef, playerData, { merge: true }).catch(e => {
                console.error("Error updating player state:", e);
            });
        }
        updateMultiplayer.lastWrite = 0; 

        function setupMultiplayerListeners() {
            if (!db || !userId) return;

            // 1. Player Listener: Syncs other players
            onSnapshot(playersCollectionRef(), (snapshot) => {
                snapshot.docChanges().forEach(change => {
                    const playerId = change.doc.id;
                    const data = change.doc.data();

                    if (playerId === userId) return; // Skip local player

                    if (change.type === "added" || change.type === "modified") {
                        let otherPlayer = otherPlayers.get(playerId);
                        if (!otherPlayer) {
                            otherPlayer = createOtherPlayerMesh(playerId);
                            otherPlayers.set(playerId, otherPlayer);
                            console.log(`Player ${playerId} joined.`);
                        }
                        // Update position (p) and rotation (rY)
                        // Subtract player.height because the cylinder is centered and playerContainer is base on ground
                        otherPlayer.position.set(data.p[0], data.p[1] - player.height, data.p[2]); 
                        otherPlayer.rotation.y = data.rY;
                    } 
                    
                    if (change.type === "removed") {
                        const playerToRemove = otherPlayers.get(playerId);
                        if (playerToRemove) {
                            scene.remove(playerToRemove);
                            otherPlayers.delete(playerId);
                            console.log(`Player ${playerId} left.`);
                        }
                    }
                });
            });

            // 2. Target Listener: Syncs hit status of game objects
            onSnapshot(targetsCollectionRef(), (snapshot) => {
                snapshot.docChanges().forEach(change => {
                    const targetId = change.doc.id;
                    const data = change.doc.data();

                    if (change.type === "added") {
                        // Create the shape locally
                        const position = new THREE.Vector3(data.p[0], data.p[1], data.p[2]);
                        const targetMesh = createLocalTargetMesh(position, data.sI, data.cI);
                        targetMeshToId.set(targetId, targetMesh);
                        targets.push(targetMesh);
                        
                        // If it was already hit before we joined, mark it as hit
                        if (data.isHit) {
                            targetMesh.userData.isHit = true;
                            targetMesh.material.color.setHex(0x881337); 
                        }
                    }
                    
                    if (change.type === "modified") {
                        const targetMesh = targetMeshToId.get(targetId);
                        if (targetMesh && data.isHit && !targetMesh.userData.isHit) {
                            // Target was hit by someone! Update locally.
                            targetMesh.userData.isHit = true;
                            targetMesh.material.color.setHex(0x881337);
                            console.log(`Target ${targetId} was hit by ${data.lastHitBy}`);
                        }
                    }
                });
            });
        }
        
        // --- GAME OBJECT CREATION ---

        function createProjectile() {
            // (Same as before)
            const geometry = new THREE.SphereGeometry(0.2, 8, 8);
            const material = new THREE.MeshBasicMaterial({ color: 0xffa500 }); 
            const projectile = new THREE.Mesh(geometry, material);

            const worldQuaternion = new THREE.Quaternion();
            camera.getWorldQuaternion(worldQuaternion);
            
            const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(worldQuaternion);
            projectile.userData.velocity = forward.multiplyScalar(projectileSpeed);

            const spawnOffset = new THREE.Vector3(0, 0, -2);
            spawnOffset.applyQuaternion(worldQuaternion);
            
            projectile.position.copy(playerContainer.position).add(spawnOffset);
            
            projectile.name = 'Projectile';
            scene.add(projectile);
            projectiles.push(projectile);
        }

        // --- MOVEMENT & INPUT HANDLERS ---
        const keyState = { w: false, a: false, s: false, d: false, space: false };

        function onKeyDown(event) {
            switch (event.code) {
                case 'KeyW': keyState.w = true; break;
                case 'KeyA': keyState.a = true; break;
                case 'KeyS': keyState.s = true; break;
                case 'KeyD': keyState.d = true; break;
                case 'Space': keyState.space = true; break;
            }
        }

        function onKeyUp(event) {
            switch (event.code) {
                case 'KeyW': keyState.w = false; break;
                case 'KeyA': keyState.a = false; break;
                case 'KeyS': keyState.s = false; break;
                case 'KeyD': keyState.d = false; break;
            }
        }
        
        async function onShoot() {
            if (isLocked && player.isAlive) {
                createProjectile();
            }
            
            if (!player.isAlive && !isLocked) {
                // If game is over, restart local player state and world targets (via listener update)
                resetGame();
                document.body.requestPointerLock(); 

                // OPTIONAL: Delete the player document on death/reset, letting the listener clean up
                if (db && userId) {
                    const playerRef = doc(playersCollectionRef(), userId);
                    await setDoc(playerRef, { health: 100, score: 0, timestamp: serverTimestamp() }, { merge: true });
                }
            }
        }

        // --- POINTER LOCK CONTROLS (Setup is the same) ---
        function setupPointerLock() {
            // ... (Pointer Lock logic remains the same for brevity, assuming it works)
            const element = document.body;

            const pointerLockChange = (event) => {
                if (document.pointerLockElement === element) {
                    isLocked = true;
                    lockMessage.classList.add('opacity-0', 'pointer-events-none');
                    lockMessage.classList.remove('opacity-100');
                    crosshair.style.opacity = 1;
                } else {
                    isLocked = false;
                    lockMessage.classList.add('opacity-100', 'pointer-events-auto');
                    lockMessage.classList.remove('opacity-0');
                    
                    if (player.isAlive) {
                         lockMessage.querySelector('h2').innerText = "Click to Enter the Game";
                         lockMessage.querySelector('p').innerText = "WASD: Move | SPACE: Jump | Left Click: Shoot";
                         lockHint.innerText = "Press ESC to unlock the mouse.";
                    }
                    crosshair.style.opacity = 0;
                }
            };

            document.addEventListener('pointerlockchange', pointerLockChange, false);

            lockMessage.addEventListener('click', () => {
                if (player.isAlive) {
                    element.requestPointerLock();
                } else {
                    onShoot(); 
                }
            });

            document.addEventListener('mousemove', (event) => {
                if (isLocked) {
                    const movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
                    const movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;
                    
                    const sensitivity = 0.004; 

                    playerContainer.rotation.y -= movementX * sensitivity;

                    player.rotationX -= movementY * sensitivity;
                    player.rotationX = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, player.rotationX)); 
                    
                    camera.rotation.x = player.rotationX; 
                }
            }, false);
            
            crosshair.style.opacity = 0;
        }

        // --- COLLISION CHECK HELPER (Same as before, checking against local meshes) ---

        function checkCubeCollision(position, moveDelta, targetShape) {
            if (targetShape.userData.isHit) return null; 

            const shapePos = targetShape.position;
            const shapeHalfSize = TARGET_HALF_SIZE; 
            const playerRadius = player.radius;

            if (position.y - player.height + 0.1 > shapePos.y + shapeHalfSize || 
                position.y < shapePos.y - shapeHalfSize + COLLISION_BUFFER 
            ) {
                return null;
            }

            const nextX = position.x + moveDelta.x;
            const nextZ = position.z + moveDelta.z;
            
            const minX = shapePos.x - shapeHalfSize - playerRadius;
            const maxX = shapePos.x + shapeHalfSize + playerRadius;
            const minZ = shapePos.z - shapeHalfSize - playerRadius;
            const maxZ = shapePos.z + shapeHalfSize + playerRadius;

            if (nextX > minX && nextX < maxX && nextZ > minZ && nextZ < maxZ) {
                const dx = nextX - shapePos.x;
                const dz = nextZ - shapePos.z;
                
                let pushX = 0;
                let pushZ = 0;

                if (Math.abs(dx) > Math.abs(dz)) {
                    if (dx > 0) { pushX = maxX - nextX; } else { pushX = minX - nextX; }
                    return { x: pushX, z: 0 }; 
                } else {
                    if (dz > 0) { pushZ = maxZ - nextZ; } else { pushZ = minZ - nextZ; }
                    return { x: 0, z: pushZ };
                }
            }
            return null;
        }


        // --- GAME LOGIC ---

        function updatePlayer(delta) {
            // ... (Player movement and physics remain the same)
            if (!isLocked || !player.isAlive) return;

            const isStunned = player.landingTimer > 0;
            if (isStunned) {
                player.landingTimer -= delta;
            }

            player.velocity.x = 0;
            player.velocity.z = 0;
            
            if (!isStunned) {
                player.direction.z = keyState.w ? 1 : keyState.s ? -1 : 0;
                player.direction.x = keyState.d ? 1 : keyState.a ? -1 : 0;
                player.direction.normalize(); 

                const desiredVelocity = new THREE.Vector3(); 

                if (player.direction.z !== 0 || player.direction.x !== 0) {
                    const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(playerContainer.quaternion);
                    const right = new THREE.Vector3(1, 0, 0).applyQuaternion(playerContainer.quaternion);
                    
                    forward.y = 0;
                    right.y = 0;
                    forward.normalize();
                    right.normalize();

                    desiredVelocity.add(forward.multiplyScalar(player.direction.z * player.moveSpeed));
                    desiredVelocity.add(right.multiplyScalar(player.direction.x * player.moveSpeed));
                    
                    const horizontalVelocityMagnitude = Math.sqrt(desiredVelocity.x * desiredVelocity.x + desiredVelocity.z * desiredVelocity.z);
                    if (horizontalVelocityMagnitude > player.moveSpeed) {
                        const ratio = player.moveSpeed / horizontalVelocityMagnitude;
                        desiredVelocity.x *= ratio;
                        desiredVelocity.z *= ratio;
                    }
                    
                    player.velocity.x = desiredVelocity.x;
                    player.velocity.z = desiredVelocity.z;
                }
            }
            
            if (!isStunned && keyState.space && player.onGround) {
                player.velocity.y = player.jumpForce;
                player.onGround = false; 
            }

            player.velocity.y -= player.gravity * delta;

            const moveDelta = new THREE.Vector3(player.velocity.x * delta, 0, player.velocity.z * delta);
            
            for (const target of targets) {
                const correction = checkCubeCollision(playerContainer.position, moveDelta, target);
                
                if (correction) {
                    if (correction.x !== 0) { moveDelta.x = 0; player.velocity.x = 0; }
                    if (correction.z !== 0) { moveDelta.z = 0; player.velocity.z = 0; }
                }
            }
            
            playerContainer.position.x += moveDelta.x;
            playerContainer.position.z += moveDelta.z;

            const boundary = WORLD_SIZE / 2 - player.radius;
            playerContainer.position.x = Math.max(-boundary, Math.min(boundary, playerContainer.position.x));
            playerContainer.position.z = Math.max(-boundary, Math.min(boundary, playerContainer.position.z));
            
            const proposedY = playerContainer.position.y + player.velocity.y * delta;

            const GROUND_Y = player.height; 
            const justLanded = !player.onGround && proposedY <= GROUND_Y;

            if (proposedY <= GROUND_Y) {
                playerContainer.position.y = GROUND_Y;
                player.onGround = true;
                
                if (justLanded) {
                    player.landingTimer = player.landingStunDuration; 
                    keyState.space = false; 
                }
                
                player.velocity.y = 0; 

            } else {
                playerContainer.position.y = proposedY;
                player.onGround = false;
            }
        }

        function updateProjectiles(delta) {
            const raycaster = new THREE.Raycaster();
            const projectilesToRemove = [];

            for (let i = 0; i < projectiles.length; i++) {
                const projectile = projectiles[i];
                const velocity = projectile.userData.velocity;

                projectile.position.addScaledVector(velocity, delta);

                const direction = velocity.clone().normalize();
                raycaster.set(projectile.position, direction);
                
                const intersects = raycaster.intersectObjects(targets, false);

                if (intersects.length > 0) {
                    const intersection = intersects[0];
                    if (intersection.distance < velocity.length() * delta) {
                        
                        projectilesToRemove.push(projectile);
                        
                        const target = intersection.object;
                        
                        // MULTIPLAYER HIT LOGIC: Update Firestore
                        if (!target.userData.isHit && db && userId) {
                            
                            const targetId = getFirestoreIdFromMesh(target);
                            if (targetId) {
                                // Mark the target as hit in the database
                                const targetRef = doc(targetsCollectionRef(), targetId);
                                updateDoc(targetRef, {
                                    isHit: true,
                                    lastHitBy: userId,
                                    hitTime: serverTimestamp() 
                                }).then(() => {
                                    // Local score and visual change for immediate feedback
                                    target.userData.isHit = true; 
                                    target.material.color.setHex(0x881337); 
                                    score += 1; 
                                    updateUI(); 
                                }).catch(e => {
                                    console.error("Error updating target hit status:", e);
                                });
                            }
                        }
                    }
                }
                
                // Remove projectile if it flies too far
                if (projectile.position.length() > WORLD_SIZE || projectile.position.y > WALL_HEIGHT + 1) { 
                    projectilesToRemove.push(projectile);
                }
            }

            projectilesToRemove.forEach(projectile => {
                scene.remove(projectile);
                const index = projectiles.indexOf(projectile);
                if (index > -1) projectiles.splice(index, 1);
            });
            
        }

        function updateTargets(delta) {
            const playerPosition = playerContainer.position;
            const timeInSeconds = performance.now() / 1000;

            targets.forEach((shape, index) => {
                const isTargetHit = shape.userData.isHit;
                
                if (!isTargetHit && player.isAlive) {
                    
                    const direction = playerPosition.clone().sub(shape.position);
                    const distance = direction.length();
                    
                    if (distance < DAMAGE_RANGE) {
                        player.health -= DAMAGE_PER_SECOND * delta;
                        player.health = Math.max(0, player.health);
                        updateUI();
                        
                        direction.normalize().negate().multiplyScalar(delta * 10);
                        shape.position.add(direction); 
                        
                    } else if (distance < 50) {
                        direction.normalize().multiplyScalar(ENEMY_SPEED * delta);
                        shape.position.add(direction);
                        
                        shape.rotation.y += 0.8 * delta;
                        shape.position.y = shape.userData.initialY + 
                                          Math.sin(timeInSeconds * 2 + index) * 0.3;
                    } else {
                        shape.rotation.y += 0.5 * delta;
                        shape.position.y = shape.userData.initialY + 
                                          Math.sin(timeInSeconds * 1 + index) * 0.5;
                    }
                } else {
                    shape.rotation.y += 0.5 * delta;
                    shape.position.y = shape.userData.initialY + 
                                      Math.sin(timeInSeconds * 1 + index) * 0.5;
                }
                
                shape.rotation.x += 0.2 * delta;
                shape.rotation.z += 0.3 * delta;
            });
            
            // Check for Game Over after applying damage
            if (player.health <= 0 && player.isAlive) {
                player.isAlive = false;
                
                document.exitPointerLock();
                
                lockMessage.querySelector('h2').innerText = "GAME OVER";
                lockMessage.querySelector('p').innerText = "Final Score: " + score;
                lockHint.innerText = "Click to restart the game.";
                
                lockMessage.classList.remove('opacity-0', 'pointer-events-none');
                lockMessage.classList.add('opacity-100', 'pointer-events-auto');
            }
        }


        // --- ANIMATION LOOP ---
        function animate() {
            requestAnimationFrame(animate);

            const time = performance.now();
            const delta = (time - lastTime) / 1000; 
            lastTime = time;

            if (player.isAlive && isLocked) {
                updatePlayer(delta);
                updateProjectiles(delta);
                updateMultiplayer(delta); // Send/Receive player positions
            }
            
            updateTargets(delta); 

            renderer.render(scene, camera);
        }

        // --- WINDOW RESIZE ---
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Initialize the game when the window loads
        window.onload = function () {
            init();
        }

    </script>
</body>
</html>
